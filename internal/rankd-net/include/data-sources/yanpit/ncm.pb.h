// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ncm.proto

#ifndef PROTOBUF_INCLUDED_ncm_2eproto
#define PROTOBUF_INCLUDED_ncm_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_ncm_2eproto 

namespace protobuf_ncm_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_ncm_2eproto
class Gps;
class GpsDefaultTypeInternal;
extern GpsDefaultTypeInternal _Gps_default_instance_;
class Handover;
class HandoverDefaultTypeInternal;
extern HandoverDefaultTypeInternal _Handover_default_instance_;
class Ncm;
class NcmDefaultTypeInternal;
extern NcmDefaultTypeInternal _Ncm_default_instance_;
class NeighborStation;
class NeighborStationDefaultTypeInternal;
extern NeighborStationDefaultTypeInternal _NeighborStation_default_instance_;
class State;
class StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
namespace google {
namespace protobuf {
template<> ::Gps* Arena::CreateMaybeMessage<::Gps>(Arena*);
template<> ::Handover* Arena::CreateMaybeMessage<::Handover>(Arena*);
template<> ::Ncm* Arena::CreateMaybeMessage<::Ncm>(Arena*);
template<> ::NeighborStation* Arena::CreateMaybeMessage<::NeighborStation>(Arena*);
template<> ::State* Arena::CreateMaybeMessage<::State>(Arena*);
}  // namespace protobuf
}  // namespace google

enum ConnectionState {
  DISCONNECTED = 0,
  CONNECTED_CELLULAR = 1,
  CONNECTED_WAVE = 2,
  ERRONEOUS_STATE = 3,
  ConnectionState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ConnectionState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ConnectionState_IsValid(int value);
const ConnectionState ConnectionState_MIN = DISCONNECTED;
const ConnectionState ConnectionState_MAX = ERRONEOUS_STATE;
const int ConnectionState_ARRAYSIZE = ConnectionState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionState_descriptor();
inline const ::std::string& ConnectionState_Name(ConnectionState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionState_descriptor(), value);
}
inline bool ConnectionState_Parse(
    const ::std::string& name, ConnectionState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionState>(
    ConnectionState_descriptor(), name, value);
}
enum HandoverType {
  REGULAR_HANDOVER = 0,
  SLOW_HANDOVER = 1,
  ERRONEOUS_HANDOVER = 2,
  HandoverType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  HandoverType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool HandoverType_IsValid(int value);
const HandoverType HandoverType_MIN = REGULAR_HANDOVER;
const HandoverType HandoverType_MAX = ERRONEOUS_HANDOVER;
const int HandoverType_ARRAYSIZE = HandoverType_MAX + 1;

const ::google::protobuf::EnumDescriptor* HandoverType_descriptor();
inline const ::std::string& HandoverType_Name(HandoverType value) {
  return ::google::protobuf::internal::NameOfEnum(
    HandoverType_descriptor(), value);
}
inline bool HandoverType_Parse(
    const ::std::string& name, HandoverType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HandoverType>(
    HandoverType_descriptor(), name, value);
}
// ===================================================================

class Gps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gps) */ {
 public:
  Gps();
  virtual ~Gps();

  Gps(const Gps& from);

  inline Gps& operator=(const Gps& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Gps(Gps&& from) noexcept
    : Gps() {
    *this = ::std::move(from);
  }

  inline Gps& operator=(Gps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Gps& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Gps* internal_default_instance() {
    return reinterpret_cast<const Gps*>(
               &_Gps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Gps* other);
  friend void swap(Gps& a, Gps& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Gps* New() const final {
    return CreateMaybeMessage<Gps>(NULL);
  }

  Gps* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Gps>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Gps& from);
  void MergeFrom(const Gps& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double longitude = 1;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  double longitude() const;
  void set_longitude(double value);

  // double latitude = 2;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  double latitude() const;
  void set_latitude(double value);

  // double track = 3;
  void clear_track();
  static const int kTrackFieldNumber = 3;
  double track() const;
  void set_track(double value);

  // double speed = 4;
  void clear_speed();
  static const int kSpeedFieldNumber = 4;
  double speed() const;
  void set_speed(double value);

  // @@protoc_insertion_point(class_scope:Gps)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double longitude_;
  double latitude_;
  double track_;
  double speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ncm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NeighborStation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NeighborStation) */ {
 public:
  NeighborStation();
  virtual ~NeighborStation();

  NeighborStation(const NeighborStation& from);

  inline NeighborStation& operator=(const NeighborStation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NeighborStation(NeighborStation&& from) noexcept
    : NeighborStation() {
    *this = ::std::move(from);
  }

  inline NeighborStation& operator=(NeighborStation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NeighborStation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NeighborStation* internal_default_instance() {
    return reinterpret_cast<const NeighborStation*>(
               &_NeighborStation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(NeighborStation* other);
  friend void swap(NeighborStation& a, NeighborStation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NeighborStation* New() const final {
    return CreateMaybeMessage<NeighborStation>(NULL);
  }

  NeighborStation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NeighborStation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NeighborStation& from);
  void MergeFrom(const NeighborStation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NeighborStation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gps location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  private:
  const ::Gps& _internal_location() const;
  public:
  const ::Gps& location() const;
  ::Gps* release_location();
  ::Gps* mutable_location();
  void set_allocated_location(::Gps* location);

  // int32 identification = 1;
  void clear_identification();
  static const int kIdentificationFieldNumber = 1;
  ::google::protobuf::int32 identification() const;
  void set_identification(::google::protobuf::int32 value);

  // bool in_range = 3;
  void clear_in_range();
  static const int kInRangeFieldNumber = 3;
  bool in_range() const;
  void set_in_range(bool value);

  // int64 timestamp = 4;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int32 signal = 5;
  void clear_signal();
  static const int kSignalFieldNumber = 5;
  ::google::protobuf::int32 signal() const;
  void set_signal(::google::protobuf::int32 value);

  // int32 average_signal = 6;
  void clear_average_signal();
  static const int kAverageSignalFieldNumber = 6;
  ::google::protobuf::int32 average_signal() const;
  void set_average_signal(::google::protobuf::int32 value);

  // double azimuth = 7;
  void clear_azimuth();
  static const int kAzimuthFieldNumber = 7;
  double azimuth() const;
  void set_azimuth(double value);

  // double tx_rate = 8;
  void clear_tx_rate();
  static const int kTxRateFieldNumber = 8;
  double tx_rate() const;
  void set_tx_rate(double value);

  // double i_throughput = 10;
  void clear_i_throughput();
  static const int kIThroughputFieldNumber = 10;
  double i_throughput() const;
  void set_i_throughput(double value);

  // double d_throughput = 11;
  void clear_d_throughput();
  static const int kDThroughputFieldNumber = 11;
  double d_throughput() const;
  void set_d_throughput(double value);

  // int32 inactive_time = 9;
  void clear_inactive_time();
  static const int kInactiveTimeFieldNumber = 9;
  ::google::protobuf::int32 inactive_time() const;
  void set_inactive_time(::google::protobuf::int32 value);

  // int32 tx_retries = 14;
  void clear_tx_retries();
  static const int kTxRetriesFieldNumber = 14;
  ::google::protobuf::int32 tx_retries() const;
  void set_tx_retries(::google::protobuf::int32 value);

  // int64 rx_bytes = 12;
  void clear_rx_bytes();
  static const int kRxBytesFieldNumber = 12;
  ::google::protobuf::int64 rx_bytes() const;
  void set_rx_bytes(::google::protobuf::int64 value);

  // int64 tx_bytes = 13;
  void clear_tx_bytes();
  static const int kTxBytesFieldNumber = 13;
  ::google::protobuf::int64 tx_bytes() const;
  void set_tx_bytes(::google::protobuf::int64 value);

  // int32 tx_fails = 15;
  void clear_tx_fails();
  static const int kTxFailsFieldNumber = 15;
  ::google::protobuf::int32 tx_fails() const;
  void set_tx_fails(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NeighborStation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gps* location_;
  ::google::protobuf::int32 identification_;
  bool in_range_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 signal_;
  ::google::protobuf::int32 average_signal_;
  double azimuth_;
  double tx_rate_;
  double i_throughput_;
  double d_throughput_;
  ::google::protobuf::int32 inactive_time_;
  ::google::protobuf::int32 tx_retries_;
  ::google::protobuf::int64 rx_bytes_;
  ::google::protobuf::int64 tx_bytes_;
  ::google::protobuf::int32 tx_fails_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ncm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:State) */ {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(State&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(State* other);
  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline State* New() const final {
    return CreateMaybeMessage<State>(NULL);
  }

  State* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<State>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gps location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  private:
  const ::Gps& _internal_location() const;
  public:
  const ::Gps& location() const;
  ::Gps* release_location();
  ::Gps* mutable_location();
  void set_allocated_location(::Gps* location);

  // .NeighborStation neighbor_station = 3;
  bool has_neighbor_station() const;
  void clear_neighbor_station();
  static const int kNeighborStationFieldNumber = 3;
  private:
  const ::NeighborStation& _internal_neighbor_station() const;
  public:
  const ::NeighborStation& neighbor_station() const;
  ::NeighborStation* release_neighbor_station();
  ::NeighborStation* mutable_neighbor_station();
  void set_allocated_neighbor_station(::NeighborStation* neighbor_station);

  // .ConnectionState connection_state = 2;
  void clear_connection_state();
  static const int kConnectionStateFieldNumber = 2;
  ::ConnectionState connection_state() const;
  void set_connection_state(::ConnectionState value);

  // @@protoc_insertion_point(class_scope:State)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gps* location_;
  ::NeighborStation* neighbor_station_;
  int connection_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ncm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Handover : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Handover) */ {
 public:
  Handover();
  virtual ~Handover();

  Handover(const Handover& from);

  inline Handover& operator=(const Handover& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Handover(Handover&& from) noexcept
    : Handover() {
    *this = ::std::move(from);
  }

  inline Handover& operator=(Handover&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Handover& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Handover* internal_default_instance() {
    return reinterpret_cast<const Handover*>(
               &_Handover_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Handover* other);
  friend void swap(Handover& a, Handover& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Handover* New() const final {
    return CreateMaybeMessage<Handover>(NULL);
  }

  Handover* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Handover>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Handover& from);
  void MergeFrom(const Handover& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Handover* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gps location = 8;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 8;
  private:
  const ::Gps& _internal_location() const;
  public:
  const ::Gps& location() const;
  ::Gps* release_location();
  ::Gps* mutable_location();
  void set_allocated_location(::Gps* location);

  // .ConnectionState source_state = 1;
  void clear_source_state();
  static const int kSourceStateFieldNumber = 1;
  ::ConnectionState source_state() const;
  void set_source_state(::ConnectionState value);

  // int32 source_gateway_id = 2;
  void clear_source_gateway_id();
  static const int kSourceGatewayIdFieldNumber = 2;
  ::google::protobuf::int32 source_gateway_id() const;
  void set_source_gateway_id(::google::protobuf::int32 value);

  // .ConnectionState destination_state = 3;
  void clear_destination_state();
  static const int kDestinationStateFieldNumber = 3;
  ::ConnectionState destination_state() const;
  void set_destination_state(::ConnectionState value);

  // int32 destination_gateway_id = 4;
  void clear_destination_gateway_id();
  static const int kDestinationGatewayIdFieldNumber = 4;
  ::google::protobuf::int32 destination_gateway_id() const;
  void set_destination_gateway_id(::google::protobuf::int32 value);

  // .HandoverType type = 5;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::HandoverType type() const;
  void set_type(::HandoverType value);

  // int32 average_signal = 6;
  void clear_average_signal();
  static const int kAverageSignalFieldNumber = 6;
  ::google::protobuf::int32 average_signal() const;
  void set_average_signal(::google::protobuf::int32 value);

  // double azimuth = 7;
  void clear_azimuth();
  static const int kAzimuthFieldNumber = 7;
  double azimuth() const;
  void set_azimuth(double value);

  // @@protoc_insertion_point(class_scope:Handover)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gps* location_;
  int source_state_;
  ::google::protobuf::int32 source_gateway_id_;
  int destination_state_;
  ::google::protobuf::int32 destination_gateway_id_;
  int type_;
  ::google::protobuf::int32 average_signal_;
  double azimuth_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ncm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ncm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Ncm) */ {
 public:
  Ncm();
  virtual ~Ncm();

  Ncm(const Ncm& from);

  inline Ncm& operator=(const Ncm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ncm(Ncm&& from) noexcept
    : Ncm() {
    *this = ::std::move(from);
  }

  inline Ncm& operator=(Ncm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ncm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ncm* internal_default_instance() {
    return reinterpret_cast<const Ncm*>(
               &_Ncm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Ncm* other);
  friend void swap(Ncm& a, Ncm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ncm* New() const final {
    return CreateMaybeMessage<Ncm>(NULL);
  }

  Ncm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ncm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ncm& from);
  void MergeFrom(const Ncm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ncm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NeighborStation stations = 4;
  int stations_size() const;
  void clear_stations();
  static const int kStationsFieldNumber = 4;
  ::NeighborStation* mutable_stations(int index);
  ::google::protobuf::RepeatedPtrField< ::NeighborStation >*
      mutable_stations();
  const ::NeighborStation& stations(int index) const;
  ::NeighborStation* add_stations();
  const ::google::protobuf::RepeatedPtrField< ::NeighborStation >&
      stations() const;

  // .State state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  private:
  const ::State& _internal_state() const;
  public:
  const ::State& state() const;
  ::State* release_state();
  ::State* mutable_state();
  void set_allocated_state(::State* state);

  // .Handover handover = 3;
  bool has_handover() const;
  void clear_handover();
  static const int kHandoverFieldNumber = 3;
  private:
  const ::Handover& _internal_handover() const;
  public:
  const ::Handover& handover() const;
  ::Handover* release_handover();
  ::Handover* mutable_handover();
  void set_allocated_handover(::Handover* handover);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Ncm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::NeighborStation > stations_;
  ::State* state_;
  ::Handover* handover_;
  ::google::protobuf::int64 timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ncm_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Gps

// double longitude = 1;
inline void Gps::clear_longitude() {
  longitude_ = 0;
}
inline double Gps::longitude() const {
  // @@protoc_insertion_point(field_get:Gps.longitude)
  return longitude_;
}
inline void Gps::set_longitude(double value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:Gps.longitude)
}

// double latitude = 2;
inline void Gps::clear_latitude() {
  latitude_ = 0;
}
inline double Gps::latitude() const {
  // @@protoc_insertion_point(field_get:Gps.latitude)
  return latitude_;
}
inline void Gps::set_latitude(double value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:Gps.latitude)
}

// double track = 3;
inline void Gps::clear_track() {
  track_ = 0;
}
inline double Gps::track() const {
  // @@protoc_insertion_point(field_get:Gps.track)
  return track_;
}
inline void Gps::set_track(double value) {
  
  track_ = value;
  // @@protoc_insertion_point(field_set:Gps.track)
}

// double speed = 4;
inline void Gps::clear_speed() {
  speed_ = 0;
}
inline double Gps::speed() const {
  // @@protoc_insertion_point(field_get:Gps.speed)
  return speed_;
}
inline void Gps::set_speed(double value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:Gps.speed)
}

// -------------------------------------------------------------------

// NeighborStation

// int32 identification = 1;
inline void NeighborStation::clear_identification() {
  identification_ = 0;
}
inline ::google::protobuf::int32 NeighborStation::identification() const {
  // @@protoc_insertion_point(field_get:NeighborStation.identification)
  return identification_;
}
inline void NeighborStation::set_identification(::google::protobuf::int32 value) {
  
  identification_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.identification)
}

// .Gps location = 2;
inline bool NeighborStation::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void NeighborStation::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::Gps& NeighborStation::_internal_location() const {
  return *location_;
}
inline const ::Gps& NeighborStation::location() const {
  const ::Gps* p = location_;
  // @@protoc_insertion_point(field_get:NeighborStation.location)
  return p != NULL ? *p : *reinterpret_cast<const ::Gps*>(
      &::_Gps_default_instance_);
}
inline ::Gps* NeighborStation::release_location() {
  // @@protoc_insertion_point(field_release:NeighborStation.location)
  
  ::Gps* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::Gps* NeighborStation::mutable_location() {
  
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::Gps>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NeighborStation.location)
  return location_;
}
inline void NeighborStation::set_allocated_location(::Gps* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:NeighborStation.location)
}

// bool in_range = 3;
inline void NeighborStation::clear_in_range() {
  in_range_ = false;
}
inline bool NeighborStation::in_range() const {
  // @@protoc_insertion_point(field_get:NeighborStation.in_range)
  return in_range_;
}
inline void NeighborStation::set_in_range(bool value) {
  
  in_range_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.in_range)
}

// int64 timestamp = 4;
inline void NeighborStation::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NeighborStation::timestamp() const {
  // @@protoc_insertion_point(field_get:NeighborStation.timestamp)
  return timestamp_;
}
inline void NeighborStation::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.timestamp)
}

// int32 signal = 5;
inline void NeighborStation::clear_signal() {
  signal_ = 0;
}
inline ::google::protobuf::int32 NeighborStation::signal() const {
  // @@protoc_insertion_point(field_get:NeighborStation.signal)
  return signal_;
}
inline void NeighborStation::set_signal(::google::protobuf::int32 value) {
  
  signal_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.signal)
}

// int32 average_signal = 6;
inline void NeighborStation::clear_average_signal() {
  average_signal_ = 0;
}
inline ::google::protobuf::int32 NeighborStation::average_signal() const {
  // @@protoc_insertion_point(field_get:NeighborStation.average_signal)
  return average_signal_;
}
inline void NeighborStation::set_average_signal(::google::protobuf::int32 value) {
  
  average_signal_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.average_signal)
}

// double azimuth = 7;
inline void NeighborStation::clear_azimuth() {
  azimuth_ = 0;
}
inline double NeighborStation::azimuth() const {
  // @@protoc_insertion_point(field_get:NeighborStation.azimuth)
  return azimuth_;
}
inline void NeighborStation::set_azimuth(double value) {
  
  azimuth_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.azimuth)
}

// double tx_rate = 8;
inline void NeighborStation::clear_tx_rate() {
  tx_rate_ = 0;
}
inline double NeighborStation::tx_rate() const {
  // @@protoc_insertion_point(field_get:NeighborStation.tx_rate)
  return tx_rate_;
}
inline void NeighborStation::set_tx_rate(double value) {
  
  tx_rate_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.tx_rate)
}

// int32 inactive_time = 9;
inline void NeighborStation::clear_inactive_time() {
  inactive_time_ = 0;
}
inline ::google::protobuf::int32 NeighborStation::inactive_time() const {
  // @@protoc_insertion_point(field_get:NeighborStation.inactive_time)
  return inactive_time_;
}
inline void NeighborStation::set_inactive_time(::google::protobuf::int32 value) {
  
  inactive_time_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.inactive_time)
}

// double i_throughput = 10;
inline void NeighborStation::clear_i_throughput() {
  i_throughput_ = 0;
}
inline double NeighborStation::i_throughput() const {
  // @@protoc_insertion_point(field_get:NeighborStation.i_throughput)
  return i_throughput_;
}
inline void NeighborStation::set_i_throughput(double value) {
  
  i_throughput_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.i_throughput)
}

// double d_throughput = 11;
inline void NeighborStation::clear_d_throughput() {
  d_throughput_ = 0;
}
inline double NeighborStation::d_throughput() const {
  // @@protoc_insertion_point(field_get:NeighborStation.d_throughput)
  return d_throughput_;
}
inline void NeighborStation::set_d_throughput(double value) {
  
  d_throughput_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.d_throughput)
}

// int64 rx_bytes = 12;
inline void NeighborStation::clear_rx_bytes() {
  rx_bytes_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NeighborStation::rx_bytes() const {
  // @@protoc_insertion_point(field_get:NeighborStation.rx_bytes)
  return rx_bytes_;
}
inline void NeighborStation::set_rx_bytes(::google::protobuf::int64 value) {
  
  rx_bytes_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.rx_bytes)
}

// int64 tx_bytes = 13;
inline void NeighborStation::clear_tx_bytes() {
  tx_bytes_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NeighborStation::tx_bytes() const {
  // @@protoc_insertion_point(field_get:NeighborStation.tx_bytes)
  return tx_bytes_;
}
inline void NeighborStation::set_tx_bytes(::google::protobuf::int64 value) {
  
  tx_bytes_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.tx_bytes)
}

// int32 tx_retries = 14;
inline void NeighborStation::clear_tx_retries() {
  tx_retries_ = 0;
}
inline ::google::protobuf::int32 NeighborStation::tx_retries() const {
  // @@protoc_insertion_point(field_get:NeighborStation.tx_retries)
  return tx_retries_;
}
inline void NeighborStation::set_tx_retries(::google::protobuf::int32 value) {
  
  tx_retries_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.tx_retries)
}

// int32 tx_fails = 15;
inline void NeighborStation::clear_tx_fails() {
  tx_fails_ = 0;
}
inline ::google::protobuf::int32 NeighborStation::tx_fails() const {
  // @@protoc_insertion_point(field_get:NeighborStation.tx_fails)
  return tx_fails_;
}
inline void NeighborStation::set_tx_fails(::google::protobuf::int32 value) {
  
  tx_fails_ = value;
  // @@protoc_insertion_point(field_set:NeighborStation.tx_fails)
}

// -------------------------------------------------------------------

// State

// .Gps location = 1;
inline bool State::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void State::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::Gps& State::_internal_location() const {
  return *location_;
}
inline const ::Gps& State::location() const {
  const ::Gps* p = location_;
  // @@protoc_insertion_point(field_get:State.location)
  return p != NULL ? *p : *reinterpret_cast<const ::Gps*>(
      &::_Gps_default_instance_);
}
inline ::Gps* State::release_location() {
  // @@protoc_insertion_point(field_release:State.location)
  
  ::Gps* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::Gps* State::mutable_location() {
  
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::Gps>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:State.location)
  return location_;
}
inline void State::set_allocated_location(::Gps* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:State.location)
}

// .ConnectionState connection_state = 2;
inline void State::clear_connection_state() {
  connection_state_ = 0;
}
inline ::ConnectionState State::connection_state() const {
  // @@protoc_insertion_point(field_get:State.connection_state)
  return static_cast< ::ConnectionState >(connection_state_);
}
inline void State::set_connection_state(::ConnectionState value) {
  
  connection_state_ = value;
  // @@protoc_insertion_point(field_set:State.connection_state)
}

// .NeighborStation neighbor_station = 3;
inline bool State::has_neighbor_station() const {
  return this != internal_default_instance() && neighbor_station_ != NULL;
}
inline void State::clear_neighbor_station() {
  if (GetArenaNoVirtual() == NULL && neighbor_station_ != NULL) {
    delete neighbor_station_;
  }
  neighbor_station_ = NULL;
}
inline const ::NeighborStation& State::_internal_neighbor_station() const {
  return *neighbor_station_;
}
inline const ::NeighborStation& State::neighbor_station() const {
  const ::NeighborStation* p = neighbor_station_;
  // @@protoc_insertion_point(field_get:State.neighbor_station)
  return p != NULL ? *p : *reinterpret_cast<const ::NeighborStation*>(
      &::_NeighborStation_default_instance_);
}
inline ::NeighborStation* State::release_neighbor_station() {
  // @@protoc_insertion_point(field_release:State.neighbor_station)
  
  ::NeighborStation* temp = neighbor_station_;
  neighbor_station_ = NULL;
  return temp;
}
inline ::NeighborStation* State::mutable_neighbor_station() {
  
  if (neighbor_station_ == NULL) {
    auto* p = CreateMaybeMessage<::NeighborStation>(GetArenaNoVirtual());
    neighbor_station_ = p;
  }
  // @@protoc_insertion_point(field_mutable:State.neighbor_station)
  return neighbor_station_;
}
inline void State::set_allocated_neighbor_station(::NeighborStation* neighbor_station) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete neighbor_station_;
  }
  if (neighbor_station) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      neighbor_station = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, neighbor_station, submessage_arena);
    }
    
  } else {
    
  }
  neighbor_station_ = neighbor_station;
  // @@protoc_insertion_point(field_set_allocated:State.neighbor_station)
}

// -------------------------------------------------------------------

// Handover

// .ConnectionState source_state = 1;
inline void Handover::clear_source_state() {
  source_state_ = 0;
}
inline ::ConnectionState Handover::source_state() const {
  // @@protoc_insertion_point(field_get:Handover.source_state)
  return static_cast< ::ConnectionState >(source_state_);
}
inline void Handover::set_source_state(::ConnectionState value) {
  
  source_state_ = value;
  // @@protoc_insertion_point(field_set:Handover.source_state)
}

// int32 source_gateway_id = 2;
inline void Handover::clear_source_gateway_id() {
  source_gateway_id_ = 0;
}
inline ::google::protobuf::int32 Handover::source_gateway_id() const {
  // @@protoc_insertion_point(field_get:Handover.source_gateway_id)
  return source_gateway_id_;
}
inline void Handover::set_source_gateway_id(::google::protobuf::int32 value) {
  
  source_gateway_id_ = value;
  // @@protoc_insertion_point(field_set:Handover.source_gateway_id)
}

// .ConnectionState destination_state = 3;
inline void Handover::clear_destination_state() {
  destination_state_ = 0;
}
inline ::ConnectionState Handover::destination_state() const {
  // @@protoc_insertion_point(field_get:Handover.destination_state)
  return static_cast< ::ConnectionState >(destination_state_);
}
inline void Handover::set_destination_state(::ConnectionState value) {
  
  destination_state_ = value;
  // @@protoc_insertion_point(field_set:Handover.destination_state)
}

// int32 destination_gateway_id = 4;
inline void Handover::clear_destination_gateway_id() {
  destination_gateway_id_ = 0;
}
inline ::google::protobuf::int32 Handover::destination_gateway_id() const {
  // @@protoc_insertion_point(field_get:Handover.destination_gateway_id)
  return destination_gateway_id_;
}
inline void Handover::set_destination_gateway_id(::google::protobuf::int32 value) {
  
  destination_gateway_id_ = value;
  // @@protoc_insertion_point(field_set:Handover.destination_gateway_id)
}

// .HandoverType type = 5;
inline void Handover::clear_type() {
  type_ = 0;
}
inline ::HandoverType Handover::type() const {
  // @@protoc_insertion_point(field_get:Handover.type)
  return static_cast< ::HandoverType >(type_);
}
inline void Handover::set_type(::HandoverType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Handover.type)
}

// int32 average_signal = 6;
inline void Handover::clear_average_signal() {
  average_signal_ = 0;
}
inline ::google::protobuf::int32 Handover::average_signal() const {
  // @@protoc_insertion_point(field_get:Handover.average_signal)
  return average_signal_;
}
inline void Handover::set_average_signal(::google::protobuf::int32 value) {
  
  average_signal_ = value;
  // @@protoc_insertion_point(field_set:Handover.average_signal)
}

// double azimuth = 7;
inline void Handover::clear_azimuth() {
  azimuth_ = 0;
}
inline double Handover::azimuth() const {
  // @@protoc_insertion_point(field_get:Handover.azimuth)
  return azimuth_;
}
inline void Handover::set_azimuth(double value) {
  
  azimuth_ = value;
  // @@protoc_insertion_point(field_set:Handover.azimuth)
}

// .Gps location = 8;
inline bool Handover::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Handover::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::Gps& Handover::_internal_location() const {
  return *location_;
}
inline const ::Gps& Handover::location() const {
  const ::Gps* p = location_;
  // @@protoc_insertion_point(field_get:Handover.location)
  return p != NULL ? *p : *reinterpret_cast<const ::Gps*>(
      &::_Gps_default_instance_);
}
inline ::Gps* Handover::release_location() {
  // @@protoc_insertion_point(field_release:Handover.location)
  
  ::Gps* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::Gps* Handover::mutable_location() {
  
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::Gps>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Handover.location)
  return location_;
}
inline void Handover::set_allocated_location(::Gps* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:Handover.location)
}

// -------------------------------------------------------------------

// Ncm

// int64 timestamp = 1;
inline void Ncm::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Ncm::timestamp() const {
  // @@protoc_insertion_point(field_get:Ncm.timestamp)
  return timestamp_;
}
inline void Ncm::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Ncm.timestamp)
}

// .State state = 2;
inline bool Ncm::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void Ncm::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) {
    delete state_;
  }
  state_ = NULL;
}
inline const ::State& Ncm::_internal_state() const {
  return *state_;
}
inline const ::State& Ncm::state() const {
  const ::State* p = state_;
  // @@protoc_insertion_point(field_get:Ncm.state)
  return p != NULL ? *p : *reinterpret_cast<const ::State*>(
      &::_State_default_instance_);
}
inline ::State* Ncm::release_state() {
  // @@protoc_insertion_point(field_release:Ncm.state)
  
  ::State* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::State* Ncm::mutable_state() {
  
  if (state_ == NULL) {
    auto* p = CreateMaybeMessage<::State>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Ncm.state)
  return state_;
}
inline void Ncm::set_allocated_state(::State* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:Ncm.state)
}

// .Handover handover = 3;
inline bool Ncm::has_handover() const {
  return this != internal_default_instance() && handover_ != NULL;
}
inline void Ncm::clear_handover() {
  if (GetArenaNoVirtual() == NULL && handover_ != NULL) {
    delete handover_;
  }
  handover_ = NULL;
}
inline const ::Handover& Ncm::_internal_handover() const {
  return *handover_;
}
inline const ::Handover& Ncm::handover() const {
  const ::Handover* p = handover_;
  // @@protoc_insertion_point(field_get:Ncm.handover)
  return p != NULL ? *p : *reinterpret_cast<const ::Handover*>(
      &::_Handover_default_instance_);
}
inline ::Handover* Ncm::release_handover() {
  // @@protoc_insertion_point(field_release:Ncm.handover)
  
  ::Handover* temp = handover_;
  handover_ = NULL;
  return temp;
}
inline ::Handover* Ncm::mutable_handover() {
  
  if (handover_ == NULL) {
    auto* p = CreateMaybeMessage<::Handover>(GetArenaNoVirtual());
    handover_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Ncm.handover)
  return handover_;
}
inline void Ncm::set_allocated_handover(::Handover* handover) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handover_;
  }
  if (handover) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handover = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handover, submessage_arena);
    }
    
  } else {
    
  }
  handover_ = handover;
  // @@protoc_insertion_point(field_set_allocated:Ncm.handover)
}

// repeated .NeighborStation stations = 4;
inline int Ncm::stations_size() const {
  return stations_.size();
}
inline void Ncm::clear_stations() {
  stations_.Clear();
}
inline ::NeighborStation* Ncm::mutable_stations(int index) {
  // @@protoc_insertion_point(field_mutable:Ncm.stations)
  return stations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NeighborStation >*
Ncm::mutable_stations() {
  // @@protoc_insertion_point(field_mutable_list:Ncm.stations)
  return &stations_;
}
inline const ::NeighborStation& Ncm::stations(int index) const {
  // @@protoc_insertion_point(field_get:Ncm.stations)
  return stations_.Get(index);
}
inline ::NeighborStation* Ncm::add_stations() {
  // @@protoc_insertion_point(field_add:Ncm.stations)
  return stations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NeighborStation >&
Ncm::stations() const {
  // @@protoc_insertion_point(field_list:Ncm.stations)
  return stations_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ConnectionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ConnectionState>() {
  return ::ConnectionState_descriptor();
}
template <> struct is_proto_enum< ::HandoverType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HandoverType>() {
  return ::HandoverType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_ncm_2eproto
