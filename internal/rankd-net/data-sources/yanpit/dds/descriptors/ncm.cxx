// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file ncm.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "data-sources/yanpit/dds/descriptors/ncm.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>


#define Ncm_Gps_max_cdr_typesize 32ULL;
#define Ncm_Handover_max_cdr_typesize 64ULL;
#define Ncm_State_max_cdr_typesize 40ULL;

#define Ncm_NcmStatus_max_cdr_typesize 12912ULL;
#define Ncm_NeighborStation_max_cdr_typesize 128ULL;

#define Ncm_Gps_max_key_cdr_typesize 0ULL;
#define Ncm_Handover_max_key_cdr_typesize 0ULL;
#define Ncm_State_max_key_cdr_typesize 0ULL;

#define Ncm_NcmStatus_max_key_cdr_typesize 8ULL;
#define Ncm_NeighborStation_max_key_cdr_typesize 0ULL;

Ncm::Gps::Gps()
{
    // double m_longitude
    m_longitude = 0.0;
    // double m_latitude
    m_latitude = 0.0;
    // double m_track
    m_track = 0.0;
    // double m_speed
    m_speed = 0.0;

}

Ncm::Gps::~Gps()
{




}

Ncm::Gps::Gps(
        const Gps& x)
{
    m_longitude = x.m_longitude;
    m_latitude = x.m_latitude;
    m_track = x.m_track;
    m_speed = x.m_speed;
}

Ncm::Gps::Gps(
        Gps&& x) noexcept 
{
    m_longitude = x.m_longitude;
    m_latitude = x.m_latitude;
    m_track = x.m_track;
    m_speed = x.m_speed;
}

Ncm::Gps& Ncm::Gps::operator =(
        const Gps& x)
{

    m_longitude = x.m_longitude;
    m_latitude = x.m_latitude;
    m_track = x.m_track;
    m_speed = x.m_speed;

    return *this;
}

Ncm::Gps& Ncm::Gps::operator =(
        Gps&& x) noexcept
{

    m_longitude = x.m_longitude;
    m_latitude = x.m_latitude;
    m_track = x.m_track;
    m_speed = x.m_speed;

    return *this;
}

bool Ncm::Gps::operator ==(
        const Gps& x) const
{

    return (m_longitude == x.m_longitude && m_latitude == x.m_latitude && m_track == x.m_track && m_speed == x.m_speed);
}

bool Ncm::Gps::operator !=(
        const Gps& x) const
{
    return !(*this == x);
}

size_t Ncm::Gps::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Ncm_Gps_max_cdr_typesize;
}

size_t Ncm::Gps::getCdrSerializedSize(
        const Ncm::Gps& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void Ncm::Gps::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_longitude;
    scdr << m_latitude;
    scdr << m_track;
    scdr << m_speed;

}

void Ncm::Gps::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_longitude;
    dcdr >> m_latitude;
    dcdr >> m_track;
    dcdr >> m_speed;
}

/*!
 * @brief This function sets a value in member longitude
 * @param _longitude New value for member longitude
 */
void Ncm::Gps::longitude(
        double _longitude)
{
    m_longitude = _longitude;
}

/*!
 * @brief This function returns the value of member longitude
 * @return Value of member longitude
 */
double Ncm::Gps::longitude() const
{
    return m_longitude;
}

/*!
 * @brief This function returns a reference to member longitude
 * @return Reference to member longitude
 */
double& Ncm::Gps::longitude()
{
    return m_longitude;
}

/*!
 * @brief This function sets a value in member latitude
 * @param _latitude New value for member latitude
 */
void Ncm::Gps::latitude(
        double _latitude)
{
    m_latitude = _latitude;
}

/*!
 * @brief This function returns the value of member latitude
 * @return Value of member latitude
 */
double Ncm::Gps::latitude() const
{
    return m_latitude;
}

/*!
 * @brief This function returns a reference to member latitude
 * @return Reference to member latitude
 */
double& Ncm::Gps::latitude()
{
    return m_latitude;
}

/*!
 * @brief This function sets a value in member track
 * @param _track New value for member track
 */
void Ncm::Gps::track(
        double _track)
{
    m_track = _track;
}

/*!
 * @brief This function returns the value of member track
 * @return Value of member track
 */
double Ncm::Gps::track() const
{
    return m_track;
}

/*!
 * @brief This function returns a reference to member track
 * @return Reference to member track
 */
double& Ncm::Gps::track()
{
    return m_track;
}

/*!
 * @brief This function sets a value in member speed
 * @param _speed New value for member speed
 */
void Ncm::Gps::speed(
        double _speed)
{
    m_speed = _speed;
}

/*!
 * @brief This function returns the value of member speed
 * @return Value of member speed
 */
double Ncm::Gps::speed() const
{
    return m_speed;
}

/*!
 * @brief This function returns a reference to member speed
 * @return Reference to member speed
 */
double& Ncm::Gps::speed()
{
    return m_speed;
}



size_t Ncm::Gps::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Ncm_Gps_max_key_cdr_typesize;
}

bool Ncm::Gps::isKeyDefined()
{
    return false;
}

void Ncm::Gps::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


Ncm::NeighborStation::NeighborStation()
{
    // long m_identification
    m_identification = 0;
    // Ncm::Gps m_location

    // boolean m_in_range
    m_in_range = false;
    // long long m_timestamp
    m_timestamp = 0;
    // long m_signal
    m_signal = 0;
    // long m_average_signal
    m_average_signal = 0;
    // double m_azimuth
    m_azimuth = 0.0;
    // double m_tx_rate
    m_tx_rate = 0.0;
    // long m_inactive_time
    m_inactive_time = 0;
    // double m_i_throughput
    m_i_throughput = 0.0;
    // double m_d_throughput
    m_d_throughput = 0.0;
    // long long m_rx_bytes
    m_rx_bytes = 0;
    // long long m_tx_bytes
    m_tx_bytes = 0;
    // long m_tx_retries
    m_tx_retries = 0;
    // long m_tx_fails
    m_tx_fails = 0;

}

Ncm::NeighborStation::~NeighborStation()
{















}

Ncm::NeighborStation::NeighborStation(
        const NeighborStation& x)
{
    m_identification = x.m_identification;
    m_location = x.m_location;
    m_in_range = x.m_in_range;
    m_timestamp = x.m_timestamp;
    m_signal = x.m_signal;
    m_average_signal = x.m_average_signal;
    m_azimuth = x.m_azimuth;
    m_tx_rate = x.m_tx_rate;
    m_inactive_time = x.m_inactive_time;
    m_i_throughput = x.m_i_throughput;
    m_d_throughput = x.m_d_throughput;
    m_rx_bytes = x.m_rx_bytes;
    m_tx_bytes = x.m_tx_bytes;
    m_tx_retries = x.m_tx_retries;
    m_tx_fails = x.m_tx_fails;
}

Ncm::NeighborStation::NeighborStation(
        NeighborStation&& x) noexcept 
{
    m_identification = x.m_identification;
    m_location = std::move(x.m_location);
    m_in_range = x.m_in_range;
    m_timestamp = x.m_timestamp;
    m_signal = x.m_signal;
    m_average_signal = x.m_average_signal;
    m_azimuth = x.m_azimuth;
    m_tx_rate = x.m_tx_rate;
    m_inactive_time = x.m_inactive_time;
    m_i_throughput = x.m_i_throughput;
    m_d_throughput = x.m_d_throughput;
    m_rx_bytes = x.m_rx_bytes;
    m_tx_bytes = x.m_tx_bytes;
    m_tx_retries = x.m_tx_retries;
    m_tx_fails = x.m_tx_fails;
}

Ncm::NeighborStation& Ncm::NeighborStation::operator =(
        const NeighborStation& x)
{

    m_identification = x.m_identification;
    m_location = x.m_location;
    m_in_range = x.m_in_range;
    m_timestamp = x.m_timestamp;
    m_signal = x.m_signal;
    m_average_signal = x.m_average_signal;
    m_azimuth = x.m_azimuth;
    m_tx_rate = x.m_tx_rate;
    m_inactive_time = x.m_inactive_time;
    m_i_throughput = x.m_i_throughput;
    m_d_throughput = x.m_d_throughput;
    m_rx_bytes = x.m_rx_bytes;
    m_tx_bytes = x.m_tx_bytes;
    m_tx_retries = x.m_tx_retries;
    m_tx_fails = x.m_tx_fails;

    return *this;
}

Ncm::NeighborStation& Ncm::NeighborStation::operator =(
        NeighborStation&& x) noexcept
{

    m_identification = x.m_identification;
    m_location = std::move(x.m_location);
    m_in_range = x.m_in_range;
    m_timestamp = x.m_timestamp;
    m_signal = x.m_signal;
    m_average_signal = x.m_average_signal;
    m_azimuth = x.m_azimuth;
    m_tx_rate = x.m_tx_rate;
    m_inactive_time = x.m_inactive_time;
    m_i_throughput = x.m_i_throughput;
    m_d_throughput = x.m_d_throughput;
    m_rx_bytes = x.m_rx_bytes;
    m_tx_bytes = x.m_tx_bytes;
    m_tx_retries = x.m_tx_retries;
    m_tx_fails = x.m_tx_fails;

    return *this;
}

bool Ncm::NeighborStation::operator ==(
        const NeighborStation& x) const
{

    return (m_identification == x.m_identification && m_location == x.m_location && m_in_range == x.m_in_range && m_timestamp == x.m_timestamp && m_signal == x.m_signal && m_average_signal == x.m_average_signal && m_azimuth == x.m_azimuth && m_tx_rate == x.m_tx_rate && m_inactive_time == x.m_inactive_time && m_i_throughput == x.m_i_throughput && m_d_throughput == x.m_d_throughput && m_rx_bytes == x.m_rx_bytes && m_tx_bytes == x.m_tx_bytes && m_tx_retries == x.m_tx_retries && m_tx_fails == x.m_tx_fails);
}

bool Ncm::NeighborStation::operator !=(
        const NeighborStation& x) const
{
    return !(*this == x);
}

size_t Ncm::NeighborStation::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Ncm_NeighborStation_max_cdr_typesize;
}

size_t Ncm::NeighborStation::getCdrSerializedSize(
        const Ncm::NeighborStation& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += Ncm::Gps::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void Ncm::NeighborStation::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_identification;
    scdr << m_location;
    scdr << m_in_range;
    scdr << m_timestamp;
    scdr << m_signal;
    scdr << m_average_signal;
    scdr << m_azimuth;
    scdr << m_tx_rate;
    scdr << m_inactive_time;
    scdr << m_i_throughput;
    scdr << m_d_throughput;
    scdr << m_rx_bytes;
    scdr << m_tx_bytes;
    scdr << m_tx_retries;
    scdr << m_tx_fails;

}

void Ncm::NeighborStation::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_identification;
    dcdr >> m_location;
    dcdr >> m_in_range;
    dcdr >> m_timestamp;
    dcdr >> m_signal;
    dcdr >> m_average_signal;
    dcdr >> m_azimuth;
    dcdr >> m_tx_rate;
    dcdr >> m_inactive_time;
    dcdr >> m_i_throughput;
    dcdr >> m_d_throughput;
    dcdr >> m_rx_bytes;
    dcdr >> m_tx_bytes;
    dcdr >> m_tx_retries;
    dcdr >> m_tx_fails;
}

/*!
 * @brief This function sets a value in member identification
 * @param _identification New value for member identification
 */
void Ncm::NeighborStation::identification(
        int32_t _identification)
{
    m_identification = _identification;
}

/*!
 * @brief This function returns the value of member identification
 * @return Value of member identification
 */
int32_t Ncm::NeighborStation::identification() const
{
    return m_identification;
}

/*!
 * @brief This function returns a reference to member identification
 * @return Reference to member identification
 */
int32_t& Ncm::NeighborStation::identification()
{
    return m_identification;
}

/*!
 * @brief This function copies the value in member location
 * @param _location New value to be copied in member location
 */
void Ncm::NeighborStation::location(
        const Ncm::Gps& _location)
{
    m_location = _location;
}

/*!
 * @brief This function moves the value in member location
 * @param _location New value to be moved in member location
 */
void Ncm::NeighborStation::location(
        Ncm::Gps&& _location)
{
    m_location = std::move(_location);
}

/*!
 * @brief This function returns a constant reference to member location
 * @return Constant reference to member location
 */
const Ncm::Gps& Ncm::NeighborStation::location() const
{
    return m_location;
}

/*!
 * @brief This function returns a reference to member location
 * @return Reference to member location
 */
Ncm::Gps& Ncm::NeighborStation::location()
{
    return m_location;
}
/*!
 * @brief This function sets a value in member in_range
 * @param _in_range New value for member in_range
 */
void Ncm::NeighborStation::in_range(
        bool _in_range)
{
    m_in_range = _in_range;
}

/*!
 * @brief This function returns the value of member in_range
 * @return Value of member in_range
 */
bool Ncm::NeighborStation::in_range() const
{
    return m_in_range;
}

/*!
 * @brief This function returns a reference to member in_range
 * @return Reference to member in_range
 */
bool& Ncm::NeighborStation::in_range()
{
    return m_in_range;
}

/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void Ncm::NeighborStation::timestamp(
        int64_t _timestamp)
{
    m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
int64_t Ncm::NeighborStation::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
int64_t& Ncm::NeighborStation::timestamp()
{
    return m_timestamp;
}

/*!
 * @brief This function sets a value in member signal
 * @param _signal New value for member signal
 */
void Ncm::NeighborStation::signal(
        int32_t _signal)
{
    m_signal = _signal;
}

/*!
 * @brief This function returns the value of member signal
 * @return Value of member signal
 */
int32_t Ncm::NeighborStation::signal() const
{
    return m_signal;
}

/*!
 * @brief This function returns a reference to member signal
 * @return Reference to member signal
 */
int32_t& Ncm::NeighborStation::signal()
{
    return m_signal;
}

/*!
 * @brief This function sets a value in member average_signal
 * @param _average_signal New value for member average_signal
 */
void Ncm::NeighborStation::average_signal(
        int32_t _average_signal)
{
    m_average_signal = _average_signal;
}

/*!
 * @brief This function returns the value of member average_signal
 * @return Value of member average_signal
 */
int32_t Ncm::NeighborStation::average_signal() const
{
    return m_average_signal;
}

/*!
 * @brief This function returns a reference to member average_signal
 * @return Reference to member average_signal
 */
int32_t& Ncm::NeighborStation::average_signal()
{
    return m_average_signal;
}

/*!
 * @brief This function sets a value in member azimuth
 * @param _azimuth New value for member azimuth
 */
void Ncm::NeighborStation::azimuth(
        double _azimuth)
{
    m_azimuth = _azimuth;
}

/*!
 * @brief This function returns the value of member azimuth
 * @return Value of member azimuth
 */
double Ncm::NeighborStation::azimuth() const
{
    return m_azimuth;
}

/*!
 * @brief This function returns a reference to member azimuth
 * @return Reference to member azimuth
 */
double& Ncm::NeighborStation::azimuth()
{
    return m_azimuth;
}

/*!
 * @brief This function sets a value in member tx_rate
 * @param _tx_rate New value for member tx_rate
 */
void Ncm::NeighborStation::tx_rate(
        double _tx_rate)
{
    m_tx_rate = _tx_rate;
}

/*!
 * @brief This function returns the value of member tx_rate
 * @return Value of member tx_rate
 */
double Ncm::NeighborStation::tx_rate() const
{
    return m_tx_rate;
}

/*!
 * @brief This function returns a reference to member tx_rate
 * @return Reference to member tx_rate
 */
double& Ncm::NeighborStation::tx_rate()
{
    return m_tx_rate;
}

/*!
 * @brief This function sets a value in member inactive_time
 * @param _inactive_time New value for member inactive_time
 */
void Ncm::NeighborStation::inactive_time(
        int32_t _inactive_time)
{
    m_inactive_time = _inactive_time;
}

/*!
 * @brief This function returns the value of member inactive_time
 * @return Value of member inactive_time
 */
int32_t Ncm::NeighborStation::inactive_time() const
{
    return m_inactive_time;
}

/*!
 * @brief This function returns a reference to member inactive_time
 * @return Reference to member inactive_time
 */
int32_t& Ncm::NeighborStation::inactive_time()
{
    return m_inactive_time;
}

/*!
 * @brief This function sets a value in member i_throughput
 * @param _i_throughput New value for member i_throughput
 */
void Ncm::NeighborStation::i_throughput(
        double _i_throughput)
{
    m_i_throughput = _i_throughput;
}

/*!
 * @brief This function returns the value of member i_throughput
 * @return Value of member i_throughput
 */
double Ncm::NeighborStation::i_throughput() const
{
    return m_i_throughput;
}

/*!
 * @brief This function returns a reference to member i_throughput
 * @return Reference to member i_throughput
 */
double& Ncm::NeighborStation::i_throughput()
{
    return m_i_throughput;
}

/*!
 * @brief This function sets a value in member d_throughput
 * @param _d_throughput New value for member d_throughput
 */
void Ncm::NeighborStation::d_throughput(
        double _d_throughput)
{
    m_d_throughput = _d_throughput;
}

/*!
 * @brief This function returns the value of member d_throughput
 * @return Value of member d_throughput
 */
double Ncm::NeighborStation::d_throughput() const
{
    return m_d_throughput;
}

/*!
 * @brief This function returns a reference to member d_throughput
 * @return Reference to member d_throughput
 */
double& Ncm::NeighborStation::d_throughput()
{
    return m_d_throughput;
}

/*!
 * @brief This function sets a value in member rx_bytes
 * @param _rx_bytes New value for member rx_bytes
 */
void Ncm::NeighborStation::rx_bytes(
        int64_t _rx_bytes)
{
    m_rx_bytes = _rx_bytes;
}

/*!
 * @brief This function returns the value of member rx_bytes
 * @return Value of member rx_bytes
 */
int64_t Ncm::NeighborStation::rx_bytes() const
{
    return m_rx_bytes;
}

/*!
 * @brief This function returns a reference to member rx_bytes
 * @return Reference to member rx_bytes
 */
int64_t& Ncm::NeighborStation::rx_bytes()
{
    return m_rx_bytes;
}

/*!
 * @brief This function sets a value in member tx_bytes
 * @param _tx_bytes New value for member tx_bytes
 */
void Ncm::NeighborStation::tx_bytes(
        int64_t _tx_bytes)
{
    m_tx_bytes = _tx_bytes;
}

/*!
 * @brief This function returns the value of member tx_bytes
 * @return Value of member tx_bytes
 */
int64_t Ncm::NeighborStation::tx_bytes() const
{
    return m_tx_bytes;
}

/*!
 * @brief This function returns a reference to member tx_bytes
 * @return Reference to member tx_bytes
 */
int64_t& Ncm::NeighborStation::tx_bytes()
{
    return m_tx_bytes;
}

/*!
 * @brief This function sets a value in member tx_retries
 * @param _tx_retries New value for member tx_retries
 */
void Ncm::NeighborStation::tx_retries(
        int32_t _tx_retries)
{
    m_tx_retries = _tx_retries;
}

/*!
 * @brief This function returns the value of member tx_retries
 * @return Value of member tx_retries
 */
int32_t Ncm::NeighborStation::tx_retries() const
{
    return m_tx_retries;
}

/*!
 * @brief This function returns a reference to member tx_retries
 * @return Reference to member tx_retries
 */
int32_t& Ncm::NeighborStation::tx_retries()
{
    return m_tx_retries;
}

/*!
 * @brief This function sets a value in member tx_fails
 * @param _tx_fails New value for member tx_fails
 */
void Ncm::NeighborStation::tx_fails(
        int32_t _tx_fails)
{
    m_tx_fails = _tx_fails;
}

/*!
 * @brief This function returns the value of member tx_fails
 * @return Value of member tx_fails
 */
int32_t Ncm::NeighborStation::tx_fails() const
{
    return m_tx_fails;
}

/*!
 * @brief This function returns a reference to member tx_fails
 * @return Reference to member tx_fails
 */
int32_t& Ncm::NeighborStation::tx_fails()
{
    return m_tx_fails;
}



size_t Ncm::NeighborStation::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Ncm_NeighborStation_max_key_cdr_typesize;
}

bool Ncm::NeighborStation::isKeyDefined()
{
    return false;
}

void Ncm::NeighborStation::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


Ncm::Handover::Handover()
{
    // Ncm::ConnectionState m_source_state
    m_source_state = Ncm::DISCONNECTED;
    // long m_source_gateway_id
    m_source_gateway_id = 0;
    // Ncm::ConnectionState m_destination_state
    m_destination_state = Ncm::DISCONNECTED;
    // long m_destination_gateway_id
    m_destination_gateway_id = 0;
    // Ncm::HandoverType m_type
    m_type = Ncm::REGULAR_HANDOVER;
    // long m_average_signal
    m_average_signal = 0;
    // double m_azimuth
    m_azimuth = 0.0;
    // Ncm::Gps m_location


}

Ncm::Handover::~Handover()
{








}

Ncm::Handover::Handover(
        const Handover& x)
{
    m_source_state = x.m_source_state;
    m_source_gateway_id = x.m_source_gateway_id;
    m_destination_state = x.m_destination_state;
    m_destination_gateway_id = x.m_destination_gateway_id;
    m_type = x.m_type;
    m_average_signal = x.m_average_signal;
    m_azimuth = x.m_azimuth;
    m_location = x.m_location;
}

Ncm::Handover::Handover(
        Handover&& x) noexcept 
{
    m_source_state = x.m_source_state;
    m_source_gateway_id = x.m_source_gateway_id;
    m_destination_state = x.m_destination_state;
    m_destination_gateway_id = x.m_destination_gateway_id;
    m_type = x.m_type;
    m_average_signal = x.m_average_signal;
    m_azimuth = x.m_azimuth;
    m_location = std::move(x.m_location);
}

Ncm::Handover& Ncm::Handover::operator =(
        const Handover& x)
{

    m_source_state = x.m_source_state;
    m_source_gateway_id = x.m_source_gateway_id;
    m_destination_state = x.m_destination_state;
    m_destination_gateway_id = x.m_destination_gateway_id;
    m_type = x.m_type;
    m_average_signal = x.m_average_signal;
    m_azimuth = x.m_azimuth;
    m_location = x.m_location;

    return *this;
}

Ncm::Handover& Ncm::Handover::operator =(
        Handover&& x) noexcept
{

    m_source_state = x.m_source_state;
    m_source_gateway_id = x.m_source_gateway_id;
    m_destination_state = x.m_destination_state;
    m_destination_gateway_id = x.m_destination_gateway_id;
    m_type = x.m_type;
    m_average_signal = x.m_average_signal;
    m_azimuth = x.m_azimuth;
    m_location = std::move(x.m_location);

    return *this;
}

bool Ncm::Handover::operator ==(
        const Handover& x) const
{

    return (m_source_state == x.m_source_state && m_source_gateway_id == x.m_source_gateway_id && m_destination_state == x.m_destination_state && m_destination_gateway_id == x.m_destination_gateway_id && m_type == x.m_type && m_average_signal == x.m_average_signal && m_azimuth == x.m_azimuth && m_location == x.m_location);
}

bool Ncm::Handover::operator !=(
        const Handover& x) const
{
    return !(*this == x);
}

size_t Ncm::Handover::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Ncm_Handover_max_cdr_typesize;
}

size_t Ncm::Handover::getCdrSerializedSize(
        const Ncm::Handover& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += Ncm::Gps::getCdrSerializedSize(data.location(), current_alignment);

    return current_alignment - initial_alignment;
}

void Ncm::Handover::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << (uint32_t)m_source_state;
    scdr << m_source_gateway_id;
    scdr << (uint32_t)m_destination_state;
    scdr << m_destination_gateway_id;
    scdr << (uint32_t)m_type;
    scdr << m_average_signal;
    scdr << m_azimuth;
    scdr << m_location;

}

void Ncm::Handover::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_source_state = (Ncm::ConnectionState)enum_value;
    }

    dcdr >> m_source_gateway_id;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_destination_state = (Ncm::ConnectionState)enum_value;
    }

    dcdr >> m_destination_gateway_id;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_type = (Ncm::HandoverType)enum_value;
    }

    dcdr >> m_average_signal;
    dcdr >> m_azimuth;
    dcdr >> m_location;
}

/*!
 * @brief This function sets a value in member source_state
 * @param _source_state New value for member source_state
 */
void Ncm::Handover::source_state(
        Ncm::ConnectionState _source_state)
{
    m_source_state = _source_state;
}

/*!
 * @brief This function returns the value of member source_state
 * @return Value of member source_state
 */
Ncm::ConnectionState Ncm::Handover::source_state() const
{
    return m_source_state;
}

/*!
 * @brief This function returns a reference to member source_state
 * @return Reference to member source_state
 */
Ncm::ConnectionState& Ncm::Handover::source_state()
{
    return m_source_state;
}

/*!
 * @brief This function sets a value in member source_gateway_id
 * @param _source_gateway_id New value for member source_gateway_id
 */
void Ncm::Handover::source_gateway_id(
        int32_t _source_gateway_id)
{
    m_source_gateway_id = _source_gateway_id;
}

/*!
 * @brief This function returns the value of member source_gateway_id
 * @return Value of member source_gateway_id
 */
int32_t Ncm::Handover::source_gateway_id() const
{
    return m_source_gateway_id;
}

/*!
 * @brief This function returns a reference to member source_gateway_id
 * @return Reference to member source_gateway_id
 */
int32_t& Ncm::Handover::source_gateway_id()
{
    return m_source_gateway_id;
}

/*!
 * @brief This function sets a value in member destination_state
 * @param _destination_state New value for member destination_state
 */
void Ncm::Handover::destination_state(
        Ncm::ConnectionState _destination_state)
{
    m_destination_state = _destination_state;
}

/*!
 * @brief This function returns the value of member destination_state
 * @return Value of member destination_state
 */
Ncm::ConnectionState Ncm::Handover::destination_state() const
{
    return m_destination_state;
}

/*!
 * @brief This function returns a reference to member destination_state
 * @return Reference to member destination_state
 */
Ncm::ConnectionState& Ncm::Handover::destination_state()
{
    return m_destination_state;
}

/*!
 * @brief This function sets a value in member destination_gateway_id
 * @param _destination_gateway_id New value for member destination_gateway_id
 */
void Ncm::Handover::destination_gateway_id(
        int32_t _destination_gateway_id)
{
    m_destination_gateway_id = _destination_gateway_id;
}

/*!
 * @brief This function returns the value of member destination_gateway_id
 * @return Value of member destination_gateway_id
 */
int32_t Ncm::Handover::destination_gateway_id() const
{
    return m_destination_gateway_id;
}

/*!
 * @brief This function returns a reference to member destination_gateway_id
 * @return Reference to member destination_gateway_id
 */
int32_t& Ncm::Handover::destination_gateway_id()
{
    return m_destination_gateway_id;
}

/*!
 * @brief This function sets a value in member type
 * @param _type New value for member type
 */
void Ncm::Handover::type(
        Ncm::HandoverType _type)
{
    m_type = _type;
}

/*!
 * @brief This function returns the value of member type
 * @return Value of member type
 */
Ncm::HandoverType Ncm::Handover::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
Ncm::HandoverType& Ncm::Handover::type()
{
    return m_type;
}

/*!
 * @brief This function sets a value in member average_signal
 * @param _average_signal New value for member average_signal
 */
void Ncm::Handover::average_signal(
        int32_t _average_signal)
{
    m_average_signal = _average_signal;
}

/*!
 * @brief This function returns the value of member average_signal
 * @return Value of member average_signal
 */
int32_t Ncm::Handover::average_signal() const
{
    return m_average_signal;
}

/*!
 * @brief This function returns a reference to member average_signal
 * @return Reference to member average_signal
 */
int32_t& Ncm::Handover::average_signal()
{
    return m_average_signal;
}

/*!
 * @brief This function sets a value in member azimuth
 * @param _azimuth New value for member azimuth
 */
void Ncm::Handover::azimuth(
        double _azimuth)
{
    m_azimuth = _azimuth;
}

/*!
 * @brief This function returns the value of member azimuth
 * @return Value of member azimuth
 */
double Ncm::Handover::azimuth() const
{
    return m_azimuth;
}

/*!
 * @brief This function returns a reference to member azimuth
 * @return Reference to member azimuth
 */
double& Ncm::Handover::azimuth()
{
    return m_azimuth;
}

/*!
 * @brief This function copies the value in member location
 * @param _location New value to be copied in member location
 */
void Ncm::Handover::location(
        const Ncm::Gps& _location)
{
    m_location = _location;
}

/*!
 * @brief This function moves the value in member location
 * @param _location New value to be moved in member location
 */
void Ncm::Handover::location(
        Ncm::Gps&& _location)
{
    m_location = std::move(_location);
}

/*!
 * @brief This function returns a constant reference to member location
 * @return Constant reference to member location
 */
const Ncm::Gps& Ncm::Handover::location() const
{
    return m_location;
}

/*!
 * @brief This function returns a reference to member location
 * @return Reference to member location
 */
Ncm::Gps& Ncm::Handover::location()
{
    return m_location;
}


size_t Ncm::Handover::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Ncm_Handover_max_key_cdr_typesize;
}

bool Ncm::Handover::isKeyDefined()
{
    return false;
}

void Ncm::Handover::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

Ncm::State::State()
{
    // Ncm::Gps m_location

    // Ncm::ConnectionState m_connection_state
    m_connection_state = Ncm::DISCONNECTED;
    // long m_neighbor_station
    m_neighbor_station = 0;

}

Ncm::State::~State()
{



}

Ncm::State::State(
        const State& x)
{
    m_location = x.m_location;
    m_connection_state = x.m_connection_state;
    m_neighbor_station = x.m_neighbor_station;
}

Ncm::State::State(
        State&& x) noexcept 
{
    m_location = std::move(x.m_location);
    m_connection_state = x.m_connection_state;
    m_neighbor_station = x.m_neighbor_station;
}

Ncm::State& Ncm::State::operator =(
        const State& x)
{

    m_location = x.m_location;
    m_connection_state = x.m_connection_state;
    m_neighbor_station = x.m_neighbor_station;

    return *this;
}

Ncm::State& Ncm::State::operator =(
        State&& x) noexcept
{

    m_location = std::move(x.m_location);
    m_connection_state = x.m_connection_state;
    m_neighbor_station = x.m_neighbor_station;

    return *this;
}

bool Ncm::State::operator ==(
        const State& x) const
{

    return (m_location == x.m_location && m_connection_state == x.m_connection_state && m_neighbor_station == x.m_neighbor_station);
}

bool Ncm::State::operator !=(
        const State& x) const
{
    return !(*this == x);
}

size_t Ncm::State::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Ncm_State_max_cdr_typesize;
}

size_t Ncm::State::getCdrSerializedSize(
        const Ncm::State& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Ncm::Gps::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void Ncm::State::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_location;
    scdr << (uint32_t)m_connection_state;
    scdr << m_neighbor_station;

}

void Ncm::State::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_location;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_connection_state = (Ncm::ConnectionState)enum_value;
    }

    dcdr >> m_neighbor_station;
}

/*!
 * @brief This function copies the value in member location
 * @param _location New value to be copied in member location
 */
void Ncm::State::location(
        const Ncm::Gps& _location)
{
    m_location = _location;
}

/*!
 * @brief This function moves the value in member location
 * @param _location New value to be moved in member location
 */
void Ncm::State::location(
        Ncm::Gps&& _location)
{
    m_location = std::move(_location);
}

/*!
 * @brief This function returns a constant reference to member location
 * @return Constant reference to member location
 */
const Ncm::Gps& Ncm::State::location() const
{
    return m_location;
}

/*!
 * @brief This function returns a reference to member location
 * @return Reference to member location
 */
Ncm::Gps& Ncm::State::location()
{
    return m_location;
}
/*!
 * @brief This function sets a value in member connection_state
 * @param _connection_state New value for member connection_state
 */
void Ncm::State::connection_state(
        Ncm::ConnectionState _connection_state)
{
    m_connection_state = _connection_state;
}

/*!
 * @brief This function returns the value of member connection_state
 * @return Value of member connection_state
 */
Ncm::ConnectionState Ncm::State::connection_state() const
{
    return m_connection_state;
}

/*!
 * @brief This function returns a reference to member connection_state
 * @return Reference to member connection_state
 */
Ncm::ConnectionState& Ncm::State::connection_state()
{
    return m_connection_state;
}

/*!
 * @brief This function sets a value in member neighbor_station
 * @param _neighbor_station New value for member neighbor_station
 */
void Ncm::State::neighbor_station(
        int32_t _neighbor_station)
{
    m_neighbor_station = _neighbor_station;
}

/*!
 * @brief This function returns the value of member neighbor_station
 * @return Value of member neighbor_station
 */
int32_t Ncm::State::neighbor_station() const
{
    return m_neighbor_station;
}

/*!
 * @brief This function returns a reference to member neighbor_station
 * @return Reference to member neighbor_station
 */
int32_t& Ncm::State::neighbor_station()
{
    return m_neighbor_station;
}



size_t Ncm::State::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Ncm_State_max_key_cdr_typesize;
}

bool Ncm::State::isKeyDefined()
{
    return false;
}

void Ncm::State::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

Ncm::NcmStatus::NcmStatus()
{
    // unsigned long long m_timestamp
    m_timestamp = 0;
    // Ncm::State m_state_item

    // Ncm::Handover m_handover_item

    // sequence<Ncm::NeighborStation> m_stations


}

Ncm::NcmStatus::~NcmStatus()
{




}

Ncm::NcmStatus::NcmStatus(
        const NcmStatus& x)
{
    m_timestamp = x.m_timestamp;
    m_state_item = x.m_state_item;
    m_handover_item = x.m_handover_item;
    m_stations = x.m_stations;
}

Ncm::NcmStatus::NcmStatus(
        NcmStatus&& x) noexcept 
{
    m_timestamp = x.m_timestamp;
    m_state_item = std::move(x.m_state_item);
    m_handover_item = std::move(x.m_handover_item);
    m_stations = std::move(x.m_stations);
}

Ncm::NcmStatus& Ncm::NcmStatus::operator =(
        const NcmStatus& x)
{

    m_timestamp = x.m_timestamp;
    m_state_item = x.m_state_item;
    m_handover_item = x.m_handover_item;
    m_stations = x.m_stations;

    return *this;
}

Ncm::NcmStatus& Ncm::NcmStatus::operator =(
        NcmStatus&& x) noexcept
{

    m_timestamp = x.m_timestamp;
    m_state_item = std::move(x.m_state_item);
    m_handover_item = std::move(x.m_handover_item);
    m_stations = std::move(x.m_stations);

    return *this;
}

bool Ncm::NcmStatus::operator ==(
        const NcmStatus& x) const
{

    return (m_timestamp == x.m_timestamp && m_state_item == x.m_state_item && m_handover_item == x.m_handover_item && m_stations == x.m_stations);
}

bool Ncm::NcmStatus::operator !=(
        const NcmStatus& x) const
{
    return !(*this == x);
}

size_t Ncm::NcmStatus::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Ncm_NcmStatus_max_cdr_typesize;
}

size_t Ncm::NcmStatus::getCdrSerializedSize(
        const Ncm::NcmStatus& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += Ncm::State::getCdrSerializedSize(data.state_item(), current_alignment);
    current_alignment += Ncm::Handover::getCdrSerializedSize(data.handover_item(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.stations().size(); ++a)
    {
        current_alignment += Ncm::NeighborStation::getCdrSerializedSize(data.stations().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void Ncm::NcmStatus::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_timestamp;
    scdr << m_state_item;
    scdr << m_handover_item;
    scdr << m_stations;

}

void Ncm::NcmStatus::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_timestamp;
    dcdr >> m_state_item;
    dcdr >> m_handover_item;
    dcdr >> m_stations;
}

/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void Ncm::NcmStatus::timestamp(
        uint64_t _timestamp)
{
    m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
uint64_t Ncm::NcmStatus::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
uint64_t& Ncm::NcmStatus::timestamp()
{
    return m_timestamp;
}

/*!
 * @brief This function copies the value in member state_item
 * @param _state_item New value to be copied in member state_item
 */
void Ncm::NcmStatus::state_item(
        const Ncm::State& _state_item)
{
    m_state_item = _state_item;
}

/*!
 * @brief This function moves the value in member state_item
 * @param _state_item New value to be moved in member state_item
 */
void Ncm::NcmStatus::state_item(
        Ncm::State&& _state_item)
{
    m_state_item = std::move(_state_item);
}

/*!
 * @brief This function returns a constant reference to member state_item
 * @return Constant reference to member state_item
 */
const Ncm::State& Ncm::NcmStatus::state_item() const
{
    return m_state_item;
}

/*!
 * @brief This function returns a reference to member state_item
 * @return Reference to member state_item
 */
Ncm::State& Ncm::NcmStatus::state_item()
{
    return m_state_item;
}
/*!
 * @brief This function copies the value in member handover_item
 * @param _handover_item New value to be copied in member handover_item
 */
void Ncm::NcmStatus::handover_item(
        const Ncm::Handover& _handover_item)
{
    m_handover_item = _handover_item;
}

/*!
 * @brief This function moves the value in member handover_item
 * @param _handover_item New value to be moved in member handover_item
 */
void Ncm::NcmStatus::handover_item(
        Ncm::Handover&& _handover_item)
{
    m_handover_item = std::move(_handover_item);
}

/*!
 * @brief This function returns a constant reference to member handover_item
 * @return Constant reference to member handover_item
 */
const Ncm::Handover& Ncm::NcmStatus::handover_item() const
{
    return m_handover_item;
}

/*!
 * @brief This function returns a reference to member handover_item
 * @return Reference to member handover_item
 */
Ncm::Handover& Ncm::NcmStatus::handover_item()
{
    return m_handover_item;
}
/*!
 * @brief This function copies the value in member stations
 * @param _stations New value to be copied in member stations
 */
void Ncm::NcmStatus::stations(
        const std::vector<Ncm::NeighborStation>& _stations)
{
    m_stations = _stations;
}

/*!
 * @brief This function moves the value in member stations
 * @param _stations New value to be moved in member stations
 */
void Ncm::NcmStatus::stations(
        std::vector<Ncm::NeighborStation>&& _stations)
{
    m_stations = std::move(_stations);
}

/*!
 * @brief This function returns a constant reference to member stations
 * @return Constant reference to member stations
 */
const std::vector<Ncm::NeighborStation>& Ncm::NcmStatus::stations() const
{
    return m_stations;
}

/*!
 * @brief This function returns a reference to member stations
 * @return Reference to member stations
 */
std::vector<Ncm::NeighborStation>& Ncm::NcmStatus::stations()
{
    return m_stations;
}


size_t Ncm::NcmStatus::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return Ncm_NcmStatus_max_key_cdr_typesize;
}

bool Ncm::NcmStatus::isKeyDefined()
{
    return true;
}

void Ncm::NcmStatus::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
   scdr << m_timestamp;
   
 
 
  
}

